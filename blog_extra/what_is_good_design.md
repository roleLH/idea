### 什么是好的设计
```
- 美美酱
- 嗯
- 美美 美美
- 巴鲁兽
- 美美 对不起
- 没关系 巴鲁兽
- 再见 我真的很感谢你
- 再见了 美美... 
- 啊
```
#### 协议
网络游戏的一部分内容就是协议的制定。当策划确定下要开发的功能时，接下来就是对应的客户端与服务器制定协议。  
协议如何制定？  
~~简单的一些规范，比如 一个 `request` 要跟 一个 `response`~~   
一般来说，静态的数据服务器都是没有必要发给客户端的，服务器只要下发诸如 配置表索引 这样的信息，剩下的由客户端自己计算即可。服务器需要下发的更多的是一些动态的数据，比如玩家需要更新背包等等。  
但是实际上会因为各种原因，也会下发一些冗余数据，无可厚非。  
这里的问题是，如何应对修改，尤其是当一个模块追加功能时？  
修改协议。  
有的时候真的没有什么好办法，设计初期完全考虑所有情况是不可能的。  
或者添加新协议，或者在原来协议上修改以应对新的内容。  
如果是某个模块整体相关的新功能，我个人比较倾向于修改原来的结构。  
比如 ：  
定义了一个简单的道具跟背包的协议。
```
message item_info {
  int32 item_id = 1;
  repeated int32 actions = 2;
  // ...
}
message bag_info {
  int32 bag_owner = 1;
  repeated item_info infos = 2;
  // ...
}
```
  
如果后来道具又追加了新的功能：熟练度。这时要怎么办呢  
一种方式是修改 `item_info`
``` 
message item_info {
  int32 item_id = 1;
  repeated int32 actions = 2;
  int32 mastery = 3;
  // ...
}
```
另外一种方式是添加新的协议单独去更新熟练度
```
message mastery_info_update {
  repeated int32 masterys = 1;
}
```
我个人会选择第一种，至少我认为这保证了道具信息的完整性。  
第二种当然也可以，甚至可以单独去更新熟练度而不用关心以前的道具结构，但是对于道具本身却要维护两个地方（道具信息和熟练度），有时就不太方便了。   
协议并不总意味着后端的数据结构。整体的道具信息可以分成两部分数据下发；多个数据也可以整合成单一的数据下发。实际要看代码整合的难度，对协议的规定等情况而定。  
总而言之，在对整体无影响的前提下，根据自己喜好制定。  
#### 代码结构  
- 分层
- A只做A该做的事
- A该做什么由他的名字决定，无论是类名还是方法名
- TaskMgr 不应该出现 GetItemById()
- 对某个配置文件操作较多，放到一个专门的lib里
- 有些特殊模块，比如成就，慎重，搞不好会写的到处都是。